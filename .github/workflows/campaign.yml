name: Campaign

# manual trigger
on:
  workflow_dispatch:
    inputs:
      harness_filter:
        description: Pattern that matches one or more harness configurations
        required: true
        default: 'BPH'
  pull_request:

env:
  KAFL_EXTRA_FLAGS: '--trace --log-crashes'

jobs:
  # build_project:
  #   runs-on: self-hosted
  #   steps:
  #     - uses: actions/checkout@v3

  #     - uses: actions/setup-python@v4
  #       with:
  #         python-version: '3.9'
  #         cache: 'pip'

  #     - name: Install make
  #       run: sudo apt install -y make

  #     - name: build
  #       run: |
  #         make deploy -- --skip-tags kernel,hardware_check,kvm_device

  #     - name: prepare linux kernel
  #       run: |
  #         cp ../bkc/kafl/linux_kernel_tdx_guest.config .config
  #         make olddefconfig
  #         make -j $(nproc)
  #       working-directory: linux-guest

  #     # https://stackoverflow.com/a/39569568/3017219
  #     # add linux-guest .git, needs for fuzz.sh
  #     - name: Build archive
  #       run: |
  #         touch build.tar
  #         tar --exclude-vcs -cf build.tar --exclude=build.tar .
  #         tar -rf build.tar linux-guest/.git
  #         gzip build.tar
  #         du -h build.tar.gz

  #     - name: Upload build artifact
  #       uses: actions/upload-artifact@v3
  #       with:
  #         name: ccc_build
  #         path: build.tar.gz

  build_matrix:
    # needs: [build_project]
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - uses: actions/checkout@v3

      - uses: actions/setup-python@v4
        with:
          python-version: '3.9'
          cache: 'pip'
      
      - run: pip install pyyaml

      - id: set-matrix
        # run: echo "matrix=$(cat .github/campaign_harness.yml | python -c 'import sys, yaml, json; data=yaml.safe_load(sys.stdin.read()); print(json.dumps(data))')" >> $GITHUB_OUTPUT
        run: |
          import os
          import sys
          import yaml
          import json
          import re
          from pprint import pprint

          with open('.github/campaign_harness.yml') as f:
            harnesses = yaml.safe_load(f.read())

            pattern = 'BPH'
            # filter harnesses
            filtered_harnesses = [h for h in harnesses if pattern in h]
            with open(os.environ['GITHUB_OUTPUT'], 'a') as o:
              matrix_include = {
                'include': [
                  {'harness': h} for h in filtered_harnesses
                ]
              }
              o.write(f"matrix={json.dumps(matrix_include)}")
        shell: python

  fuzz:
    runs-on: self-hosted
    needs: [build_matrix]
    strategy:
      matrix: ${{fromJson(needs.build_matrix.outputs.matrix)}}
      max-parallel: 1
    steps:
      # ensure workspace is cleaned up
      # (doesn't happen automatically on self-hosted runner, since it's not a fresh virtual machine)
      - run: find . -mindepth 1 -delete

      # - name: Download build artefact
      #   uses: actions/download-artifact@v3
      #   with:
      #     name: ccc_build

      # - name: Extract archive
      #   run: |
      #     tar -xf build.tar.gz
      #     rm build.tar.gz

      - name: test matrix
        run: echo ${{ matrix.name }}

      # ./scripts/config --enable ${{ matrix.name }}
      # hardcode virtio for now
      # - name: Prepare kernel config
      #   run: |
      #     ./scripts/config --enable CONFIG_TDX_FUZZ_KAFL
      #     ./scripts/config --enable CONFIG_TDX_FUZZ_HARNESS_DOINITCALLS_VIRTIO
      #   working-directory: linux-guest

      # - name: Build kernel
      #   run: |
      #     make -j $(nproc)
      #   working-directory: linux-guest
      #   env:
      #     KCFLAGS: '-fno-ipa-sra -fno-ipa-cp-clone -fno-ipa-cp'

      # - name: Run fuzzing
      #   run: |
      #     source env.sh
      #     ln -sf /boot/initrd.img initrd.cpio.gz
      #     timeout 1h $BKC_ROOT/bkc/kafl/fuzz.sh full linux-guest -t 2 -ts 1 -p $(nproc) --log-hprintf $KAFL_EXTRA_FLAGS
        # TODO: this is not working
          # WORKDIR_PATH: $RUNNER_TEMP
